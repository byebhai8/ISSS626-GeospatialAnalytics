{
  "hash": "75703652ab7ada5f587aadaba09560c1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 09\"\nauthor: \"Bhairavi Vairavelu\"\ndate: \"Oct 27 2024\"\ndate-modified: \"last-modified\"\nexecute:\n  eval: true\n  echo: true\n  message: false\n  freeze: true\n---\n\n\n# Modelling Geographical Accessibility\n\nIn this exercise, we will model geographical accessibility by using R's geospatial analysis packages.\n\n## 1.0 The data\n\nWe will be using four datasets in this exercise:\n\n-   MP14_SUBZONE_NO_SEA_PL, for URA Master Plan 2014 Subzone Boundary GIS data\n\n-   hexagons, for a 250m radius hexagons GIS data\n\n-   ELDERCARE, for GIS data showing location of eldercare services\n\n-   OD_MATRIX, for a distance matrix in csv format\n\n## 2.0 Getting Started\n\nWe will first install the necessary R packages and launch them into RStudio.\n\nThe packages needed for this exercise are:\n\n-   sf, for spatial data handling\n\n-   spatialAcc, for modelling geographical accessibility\n\n-   tidyverse, for attribute data handling\n\n-   tmap, for thematic mapping\n\n-   ggplot2, for statistical graphics\n\n-   ggstatsplot, for statistical analysis\n\nThe code chunk below installs and launches these R packages into RStudio:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tmap, SpatialAcc, sf, ggstatsplot, reshape2, tidyverse)\n```\n:::\n\n\n## 3.0 Geospatial Data Wrangling\n\n### 3.1 Importing Geospatial Data\n\nThree geospatial data will be imported using the code chunk below, which uses st_read() of sf packages to import these shapefiles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|eval: false\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_NO_SEA_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_NO_SEA_PL' from data source \n  `C:\\byebhai8\\ISSS626-GeospatialAnalytics\\Hands-On_Ex\\Hands-on_Ex09\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n\n```{.r .cell-code}\nwrite_rds(mpsz, \"data/rds/mpsz.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#|eval: false\nhexagons <- st_read(dsn = \"data/geospatial\", layer = \"hexagons\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `hexagons' from data source \n  `C:\\byebhai8\\ISSS626-GeospatialAnalytics\\Hands-On_Ex\\Hands-on_Ex09\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3125 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 21506.33 xmax: 50010.26 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\n```\n\n\n:::\n\n```{.r .cell-code}\nwrite_rds(hexagons, \"data/rds/hexagons.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#|eval: false\neldercare <- st_read(dsn = \"data/geospatial\", layer = \"ELDERCARE\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `ELDERCARE' from data source \n  `C:\\byebhai8\\ISSS626-GeospatialAnalytics\\Hands-On_Ex\\Hands-on_Ex09\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 120 features and 19 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 14481.92 ymin: 28218.43 xmax: 41665.14 ymax: 46804.9\nProjected CRS: SVY21 / Singapore TM\n```\n\n\n:::\n\n```{.r .cell-code}\nwrite_rds(eldercare, \"data/rds/eldercare.rds\")\n```\n:::\n\n\nTo read in the saved rds files:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- read_rds(\"data/rds/mpsz.rds\")\nhexagons <- read_rds(\"data/rds/hexagons.rds\")\neldercare <- read_rds(\"data/rds/eldercare.rds\")\n```\n:::\n\n\n### 3.2 Updating CRS information\n\nThe code chunk below updates the newly imported shapefiles with the correct EPSG code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_transform(mpsz, 3414)\neldercare <- st_transform(eldercare, 3414)\nhexagons <- st_transform(hexagons, 3414)\n```\n:::\n\n\nWe can now verify the projection of the newly transformed data by using st_crs() of sf package, as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(mpsz)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n\n\n:::\n:::\n\n\n### 3.3 Attribute field clean-up\n\nThere are many redundant fields in the data tables of both eldercare and hexagons. The code chunk below will be used to exclude those redundant fields. We will also add new fields called demand and capacity.\n\n\n::: {.cell}\n\n```{.r .cell-code}\neldercare <- eldercare %>%\n  select(fid, ADDRESSPOS) %>%\n  mutate(capacity = 100)\n\nhexagons <- hexagons %>%\n  select(fid) %>%\n  mutate(demand = 100)\n```\n:::\n\n\n## 4.0 Aspatial Data Wrangling\n\n### 4.1 Importing distance matrix\n\nThe code chunk below uses read_csv() of readr package to import the matrix file into RStudio as a tibble data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|eval: false\nODMatrix <- read_csv(\"data/aspatial/OD_Matrix.csv\", skip = 0)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 375000 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (6): origin_id, destination_id, entry_cost, network_cost, exit_cost, tot...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nwrite_rds(ODMatrix, \"data/rds/ODMatrix.rds\")\n```\n:::\n\n\nTo read in the saved rds files:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nODMatrix <- read_rds(\"data/rds/ODMatrix.rds\")\n```\n:::\n\n\n### 4.2 Tidying distance matrix\n\nThe code chunk below uses spread() of tidyr package to transfer the matrix from a thin format into a fat format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat <- ODMatrix %>%\n  select(origin_id, destination_id, total_cost) %>%\n  spread(destination_id, total_cost)%>%\n  select(c(-c('origin_id')))\n```\n:::\n\n\nCurrently, the distance is measured in metre because svy21 projected coordinate system is used. The code chunk below will be used to convert the unit f measurement from metre to kilometre.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat_km <- as.matrix(distmat/1000)\n```\n:::\n\n\n## 5.0 Modelling & Visualizing Accessibility using Hansen Method\n\n### 5.1 Computing Hansen's accessibility\n\nWe can compute Hansen's accessibility by using ac() of SpatialAcc package, as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            #d0 = 50,\n                            power = 2, \n                            family = \"Hansen\"))\n```\n:::\n\n\nAs the default field name is messy, we will rename it using the code chunk below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(acc_Hansen) <- \"accHansen\"\n```\n:::\n\n\nNext, we will convert the data frame into tibble format by using the code chunk below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- tbl_df(acc_Hansen)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `tbl_df()` was deprecated in dplyr 1.0.0.\nℹ Please use `tibble::as_tibble()` instead.\n```\n\n\n:::\n:::\n\n\nLastly, blind_cols() of dplyr package will be used to join this tibble data frame with the hexagons simple feature data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_Hansen <- bind_cols(hexagons, acc_Hansen)\n```\n:::\n\n\n### 5.2 Visualizing Hansen's accessibility\n\nFirst, we will extract the extend of hexagons simple feature data frame using the st_bbox() of sf package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapex <- st_bbox(hexagons)\n```\n:::\n\n\nThe code chunk below uses tmap package's functions to create a cartographic map:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\ntm_shape(hexagon_Hansen,\n         bbox = mapex) + \n  tm_fill(col = \"accHansen\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: Hansen method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n### 5.3 Statistical graphic visualization\n\nWe will now compare the distribution of Hansen's accessibility values by URA Planning Region.\n\nFirst, we need to add the planning region field:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_Hansen <- st_join(hexagon_Hansen, mpsz, \n                          join = st_intersects)\n```\n:::\n\n\nNext, we will use ggplot() to plot the distribution as a boxplot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_Hansen, \n       aes(y = log(accHansen), \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo summary function supplied, defaulting to `mean_se()`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n## 6.0 Modelling & Visualizing Accessibility using KD2SFCA Method\n\n### 6.1 Computing KD2SFCA's accessibility\n\nThe code chunk below calculates KD2SFCA's accessibility:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            d0 = 50,\n                            power = 2, \n                            family = \"KD2SFCA\"))\n\ncolnames(acc_KD2SFCA) <- \"accKD2SFCA\"\nacc_KD2SFCA <- tbl_df(acc_KD2SFCA)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `tbl_df()` was deprecated in dplyr 1.0.0.\nℹ Please use `tibble::as_tibble()` instead.\n```\n\n\n:::\n\n```{.r .cell-code}\nhexagon_KD2SFCA <- bind_cols(hexagons, acc_KD2SFCA)\n```\n:::\n\n\n### 6.2 Visualizing KD2SFCA's accessibility\n\nThe code chunk below uses tmap package's functions to create a cartographic map:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\ntm_shape(hexagon_KD2SFCA,\n         bbox = mapex) + \n  tm_fill(col = \"accKD2SFCA\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: KD2SFCA method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n### 6.3 Statistical graphic visualization\n\nWe will now compare the distribution of KD2SFCA accessibility values by URA Planning Region.\n\nFirst, we need to add the planning region field:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_KD2SFCA <- st_join(hexagon_KD2SFCA, mpsz, \n                          join = st_intersects)\n```\n:::\n\n\nNext, we will use ggplot() to plot the distribution as a boxplot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_KD2SFCA, \n       aes(y = accKD2SFCA, \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo summary function supplied, defaulting to `mean_se()`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n## 7.0 Modelling & Visualizing Accessibility using Spatial Accessibility Measure (SAM) Method\n\n### 7.1 Computing SAM accessibility\n\nThe code chunk below calculates SAM's accessibility:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_SAM <- data.frame(ac(hexagons$demand,\n                         eldercare$capacity,\n                         distmat_km, \n                         d0 = 50,\n                         power = 2, \n                         family = \"SAM\"))\n\ncolnames(acc_SAM) <- \"accSAM\"\nacc_SAM <- tbl_df(acc_SAM)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `tbl_df()` was deprecated in dplyr 1.0.0.\nℹ Please use `tibble::as_tibble()` instead.\n```\n\n\n:::\n\n```{.r .cell-code}\nhexagon_SAM <- bind_cols(hexagons, acc_SAM)\n```\n:::\n\n\n### 7.2 Visualizing SAM's accessibility\n\nThe code chunk below uses tmap package's functions to create a cartographic map:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\ntm_shape(hexagon_SAM,\n         bbox = mapex) + \n  tm_fill(col = \"accSAM\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: SAM method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 3),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n### 7.3 Statistical graphic visualization\n\nWe will now compare the distribution of SAM accessibility values by URA Planning Region.\n\nFirst, we need to add the planning region field:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_SAM <- st_join(hexagon_SAM, mpsz, \n                       join = st_intersects)\n```\n:::\n\n\nNext, we will use ggplot() to plot the distribution as a boxplot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_SAM, \n       aes(y = accSAM, \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo summary function supplied, defaulting to `mean_se()`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\nx\n",
    "supporting": [
      "Hands-on_Ex09_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}