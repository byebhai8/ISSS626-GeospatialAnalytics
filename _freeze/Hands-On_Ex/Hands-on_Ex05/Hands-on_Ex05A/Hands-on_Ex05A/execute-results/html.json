{
  "hash": "46f6b3cf230356d055e710f97e78a86a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 05A\"\nauthor: \"Bhairavi Vairavelu\"\ndate: \"Sep 29 2024\"\ndate-modified: \"last-modified\"\nexecute:\n  eval: true\n  echo: true\n  message: false\n  freeze: true\n---\n\n\n# Global Measures of Spatial Autocorrelation\n\n## 1. Overview\n\nWe will be computing Global Measures of Spatial Autocorrelation (GMSA) by using spdep package.\n\n## 2. Getting Started\n\n### 2.1 Analytical Question\n\nOur task is to apply appropriate spatial statistical methods to discover if development are evenly distributed geographically. If the answer is no, our next question will be \"is there a sign of spatial clustering\". If the answer is yes, our next question will be \"where are these clusters\".\n\n### 2.2 Study Area & Data\n\nIn our exercise, we are interested to examine the spatial patterns of a selected development indicator of Hunan Province in People's Republic of China.\n\nTwo datasets will be used\n\n-   Hunan province administrative boundary layer at country level, a shapefile\n\n-   Hunan's local development indicators in 2012, a csv file\n\n### 2.3 Analytical Tools\n\nBefore we get started, we need to ensure that spdep, sf, tmap and tidyverse packages are installed and loaded into R. The code chunk below will help with this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse)\n```\n:::\n\n\n## 3. Getting Data into R Environment\n\n### 3.1 Import shapefile into R\n\nThe code chunk below uses st_read() of sf package to import the Hunan shapefile into R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|eval: false\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Hunan' from data source \n  `C:\\byebhai8\\ISSS626-GeospatialAnalytics\\Hands-On_Ex\\Hands-on_Ex05\\Hands-on_Ex05A\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code}\nwrite_rds(hunan, \"data/rds/hunan.rds\")\n```\n:::\n\n\nThis code chunk will read the saved rds into R environment:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- read_rds(\"data/rds/hunan.rds\")\n```\n:::\n\n\n### 3.2 Import csv file into R\n\nNext, we will import Hunan_2012.csv into R using read_csv() of readr package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|eval: false\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nwrite_rds(hunan2012, \"data/rds/hunan2012.rds\")\n```\n:::\n\n\nThis code chunk will read the saved rds into R environment:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_rds(\"data/rds/hunan2012.rds\")\n```\n:::\n\n\n### 3.3 Performing Relational Join\n\nThe code chunk below will be used to update the attribute table of hunan's SpatialPolygonsDataFrame with the attribute fields of hunan2012 data frame. This is performed using the left_join() of dplyr package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|eval: false\nhunan_joined <- left_join(hunan,hunan2012) %>%\n  select(1:4, 7, 15)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(County)`\n```\n\n\n:::\n\n```{.r .cell-code}\nwrite_rds(hunan_joined, \"data/rds/hunan_joined.rds\")\n```\n:::\n\n\nThis code chunk will read the saved rds into R environment:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_joined <- read_rds(\"data/rds/hunan_joined.rds\")\n```\n:::\n\n\n### 3.4 Visualizing Regional Development Indicator\n\nWe will prepare a basemap and choropleth map to show the distribution of GDPPC 2012 by using qtm() of tmap package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequal <- tm_shape(hunan_joined) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\")\n\nquantile <- tm_shape(hunan_joined) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\")\n\ntmap_arrange(equal, \n             quantile, \n             asp=1, \n             ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05A_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n## 4. Global Measures of Spatial Autocorrelation\n\n### 4.1 Computing Contiguity Spatial Weights\n\nBefore we compute the global spatial autocorrelation statistics, we need to construct the spatial weights of the study area. These weights are used to define the neighborhood relationships between geographical units in the study area.\n\nIn this code chunk, poly2nb() of spdep is used to compute the Queen contiguity weight matrices for the study area.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan_joined, \n                queen=TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n\n\n:::\n:::\n\n\n### 4.2 Row-standardized weights matrix\n\nNext, we will assign weights to each neighboring polygon.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q <- nb2listw(wm_q, \n                   style=\"W\", \n                   zero.policy = TRUE)\nrswm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n```\n\n\n:::\n:::\n\n\n## 5. Moran's I statistics\n\n### 5.1 Moran's I test\n\nThe code chunk below performs the Moran's I statistical test using moran.test() of spdep.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoran.test(hunan_joined$GDPPC, \n           listw=rswm_q, \n           zero.policy = TRUE, \n           na.action=na.omit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  hunan_joined$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n\n\n:::\n:::\n\n\n### 5.2 Computing Monte Carlo Moran's I\n\nThe code chunk below performs permutation test for Moran's I statistical test by using moran.mc() of spdep.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbperm= moran.mc(hunan_joined$GDPPC, \n                listw=rswm_q, \n                nsim=999, \n                zero.policy = TRUE, \n                na.action=na.omit)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  hunan_joined$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n\n### 5.3 Visualizing Monte Carlo Moran's I\n\nWe can plot the distribution of the statistical values as a histogram by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.01504572\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.004371574\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06168 -0.02125 -0.01505  0.02611  0.27593 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bperm$res, \n     freq=TRUE, \n     breaks=20, \n     xlab=\"Simulated Moran's I\")\nabline(v=0, \n       col=\"red\") \n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05A_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n## 6. Geary's C statistics\n\n### 6.1 Geart's C test\n\nThe code chunk below performs Geary's C test for spatial autocorrelation by using geary.test() of spdep.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeary.test(hunan_joined$GDPPC, listw=rswm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tGeary C test under randomisation\n\ndata:  hunan_joined$GDPPC \nweights: rswm_q   \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n```\n\n\n:::\n:::\n\n\n### 6.2 Computing Monte Carlo Geary's C\n\nThe code chunk below performs permutation test for Geary's C by using geary.mc() of spdep.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbperm=geary.mc(hunan_joined$GDPPC, \n               listw=rswm_q, \n               nsim=999)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Geary C\n\ndata:  hunan_joined$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n\n### 6.3 Visualizing Monte Carlo Geary's C\n\nWe will plot a histogram to reveal the distribution of the simulation values by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.004402\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.007436493\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7142  0.9502  1.0052  1.0044  1.0595  1.2722 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bperm$res, freq=TRUE, breaks=20, xlab=\"Simulated Geary c\")\nabline(v=1, col=\"red\") \n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05A_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n## 7. Spatial Correlogram\n\n### 7.1 Moran's I correlogram\n\nIn the code chunk below, sp.correlogram() of spdep is used to compute a 6-lag spatial correlogram of GDPPC. Then, plot() of base graph is used to plot the output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMI_corr <- sp.correlogram(wm_q, \n                          hunan_joined$GDPPC, \n                          order=6, \n                          method=\"I\", \n                          style=\"W\")\nplot(MI_corr)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05A_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\nWe should also examine the full analysis report by printing out the analysis results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(MI_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatial correlogram for hunan_joined$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\n### 7.2 Geary's C correlogram\n\nLikewise, we will perform the same computation for Geary's C.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGC_corr <- sp.correlogram(wm_q, \n                          hunan_joined$GDPPC, \n                          order=6, \n                          method=\"C\", \n                          style=\"W\")\nplot(GC_corr)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05A_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\nLet's also print out the analysis report.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(GC_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatial correlogram for hunan_joined$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex05A_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}